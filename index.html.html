<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon-Shot AR | AI Insight</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #video-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        .neon-text { text-shadow: 0 0 10px rgba(0,255,255,0.8), 0 0 20px rgba(0,255,255,0.5); }
        .cyber-border { border: 1px solid rgba(0, 255, 255, 0.3); background: rgba(0, 20, 40, 0.6); backdrop-filter: blur(8px); }
        @keyframes float-up { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-100px); } }
        .floating-text { position: absolute; pointer-events: none; animation: float-up 1s forwards; font-weight: bold; }
    </style>
</head>
<body>

<video id="video-overlay" autoplay playsinline></video>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

// --- AUDIO ENGINE (Web Audio API) ---
const AudioEngine = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    playHit(isMystery = false) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = isMystery ? 'square' : 'triangle';
        osc.frequency.setValueAtTime(isMystery ? 150 : 440, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    },
    playMiss() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }
};

// --- GAME CONFIG & STATE ---
const CONFIG = {
    ENEMY_COUNT: 4,
    MYSTERY_CHANCE: 0.15,
    DETECTION_FREQ: 15, // FPS for MediaPipe
    SMOOTHING_NORMAL: 0.25,
    SMOOTHING_FIRE: 0.08, // Higher damping (lower alpha) during recoil
    MAGNETIC_PULL: 0.15
};

// --- REACT UI COMPONENT ---
const App = () => {
    const [status, setStatus] = useState('LOADING MODELS...');
    const [score, setScore] = useState(0);
    const [combo, setCombo] = useState(0);
    const [fps, setFps] = useState(0);
    const gameRef = useRef(null);

    useEffect(() => {
        initGame();
    }, []);

    const initGame = async () => {
        const videoElement = document.getElementById('video-overlay');
        const hands = new Hands({
            locateFile: (file) => `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.PointLight(0x00ffff, 1, 100);
        light.position.set(0, 0, 10);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // Game World Objects
        const enemies = [];
        const crosshair = new THREE.Group();
        const ring = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.06, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
        crosshair.add(ring);
        scene.add(crosshair);

        const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]);
        const laserMat = new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.6 });
        const laser = new THREE.Line(laserGeo, laserMat);
        scene.add(laser);

        // State Tracking
        let lastAim = new THREE.Vector2(0, 0);
        let currentAim = new THREE.Vector2(0, 0);
        let isCalibrated = false;
        let calibStart = 0;
        let lastFired = 0;
        let comboTimer = 0;
        let shakeIntensity = 0;

        // Enemy Factory
        const spawnEnemy = () => {
            const isMystery = Math.random() < CONFIG.MYSTERY_CHANCE;
            const geo = new THREE.TorusGeometry(0.3, 0.05, 16, 100);
            const mat = new THREE.MeshStandardMaterial({ 
                color: isMystery ? 0xffd700 : 0x00f2ff, 
                emissive: isMystery ? 0xffaa00 : 0x0066ff,
                emissiveIntensity: 2
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Random start position (edges)
            const angle = Math.random() * Math.PI * 2;
            mesh.position.set(Math.cos(angle) * 8, Math.sin(angle) * 6, -10);
            
            return {
                mesh,
                isMystery,
                velocity: new THREE.Vector3(-mesh.position.x * 0.01, -mesh.position.y * 0.01, 0),
                wobble: Math.random() * 10,
                speedMult: isMystery ? 2.5 : 1
            };
        };

        for(let i=0; i<CONFIG.ENEMY_COUNT; i++) {
            const e = spawnEnemy();
            enemies.push(e);
            scene.add(e.mesh);
        }

        // --- GESTURE PROCESSING (15 FPS) ---
        let lastDetectionTime = 0;
        hands.onResults((results) => {
            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Calibration Logic
                    if (!isCalibrated) {
                        if (calibStart === 0) calibStart = Date.now();
                        if (Date.now() - calibStart > 1000) {
                            isCalibrated = true;
                            setStatus('READY');
                        } else {
                            setStatus(`CALIBRATING... ${Math.round((Date.now()-calibStart)/10)}%`);
                        }
                    }

                    // Gesture: Pistol Aiming (Index Extended)
                    // We map 0-1 range to screen space -5 to 5
                    const indexTip = landmarks[8];
                    const indexMcp = landmarks[5];
                    const rawX = (0.5 - indexTip.x) * 12;
                    const rawY = (0.5 - indexTip.y) * 8;
                    
                    // Gesture: Firing (Thumb toward Palm)
                    const thumbTip = landmarks[4];
                    const pinkyMcp = landmarks[17];
                    const dist = Math.hypot(thumbTip.x - pinkyMcp.x, thumbTip.y - pinkyMcp.y);
                    const isFiring = dist < 0.08;

                    // Adaptive Smoothing
                    const alpha = isFiring ? CONFIG.SMOOTHING_FIRE : CONFIG.SMOOTHING_NORMAL;
                    currentAim.x = lastAim.x + (rawX - lastAim.x) * alpha;
                    currentAim.y = lastAim.y + (rawY - lastAim.y) * alpha;
                    lastAim.copy(currentAim);

                    // Magnetic Aim Assist
                    enemies.forEach(e => {
                        const distToTarget = currentAim.distanceTo(new THREE.Vector2(e.mesh.position.x, e.mesh.position.y));
                        if(distToTarget < 0.8) {
                            currentAim.lerp(new THREE.Vector2(e.mesh.position.x, e.mesh.position.y), CONFIG.MAGNETIC_PULL);
                        }
                    });

                    // Fire Action
                    if (isFiring && Date.now() - lastFired > 400 && isCalibrated) {
                        checkHit(currentAim);
                        lastFired = Date.now();
                    }

                    // Laser Positioning
                    laser.position.set(currentAim.x, currentAim.y, -1);
                    laser.lookAt(currentAim.x, currentAim.y, -10);
                } else {
                    calibStart = 0;
                    if(isCalibrated) setStatus('HAND LOST');
                }
            } catch (err) { console.error("Detection Error", err); }
        });

        const checkHit = (pos) => {
            let hit = false;
            enemies.forEach((e, index) => {
                const dist = Math.hypot(e.mesh.position.x - pos.x, e.mesh.position.y - pos.y);
                if (dist < 0.6) {
                    hit = true;
                    const points = e.isMystery ? 500 : 100;
                    if (e.isMystery) shakeIntensity = 0.5;
                    
                    setScore(prev => prev + points);
                    setCombo(prev => prev + 1);
                    comboTimer = Date.now();
                    AudioEngine.playHit(e.isMystery);
                    createFloatingText(e.isMystery ? "CRITICAL!" : "HIT", pos);
                    
                    // Respawn
                    scene.remove(e.mesh);
                    enemies[index] = spawnEnemy();
                    scene.add(enemies[index].mesh);
                }
            });

            if (!hit) {
                setCombo(0);
                AudioEngine.playMiss();
                createFloatingText("MISS", pos, "#ff4444");
            }
        };

        const createFloatingText = (txt, pos, color = "#00ffff") => {
            const div = document.createElement('div');
            div.className = 'floating-text neon-text';
            div.style.left = `${((pos.x + 6)/12) * 100}%`;
            div.style.top = `${((-(pos.y) + 4)/8) * 100}%`;
            div.style.color = color;
            div.innerText = txt;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        };

        // --- RENDER LOOP (60 FPS) ---
        const cameraHelper = new Camera(videoElement, {
            onFrame: async () => {
                const now = Date.now();
                if (now - lastDetectionTime > (1000 / CONFIG.DETECTION_FREQ)) {
                    await hands.send({ image: videoElement });
                    lastDetectionTime = now;
                }
            },
            width: 1280,
            height: 720
        });

        cameraHelper.start().then(() => setStatus('CALIBRATING...'));

        const animate = (time) => {
            requestAnimationFrame(animate);

            // Update Crosshair
            crosshair.position.set(currentAim.x, currentAim.y, -5);
            crosshair.rotation.z += 0.05;

            // Update Enemies
            enemies.forEach((e, index) => {
                e.wobble += 0.05;
                const lateral = Math.sin(e.wobble) * 0.02;
                e.mesh.position.add(e.velocity.clone().multiplyScalar(e.speedMult));
                e.mesh.position.x += lateral;
                e.mesh.rotation.x += 0.02;
                e.mesh.rotation.y += 0.03;

                // Reset if reached center
                if (e.mesh.position.length() < 0.5) {
                    scene.remove(e.mesh);
                    enemies[index] = spawnEnemy();
                    scene.add(enemies[index].mesh);
                }
            });

            // Camera Shake
            if (shakeIntensity > 0) {
                camera.position.set(
                    (Math.random() - 0.5) * shakeIntensity,
                    (Math.random() - 0.5) * shakeIntensity,
                    0
                );
                shakeIntensity *= 0.9;
            } else {
                camera.position.set(0, 0, 0);
            }

            // Combo Timeout
            if (Date.now() - comboTimer > 1500 && comboTimer !== 0) {
                setCombo(0);
                comboTimer = 0;
            }

            renderer.render(scene, camera);
        };
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    };

    return (
        <div className="fixed inset-0 pointer-events-none select-none text-white p-8 flex flex-col justify-between">
            {/* Top HUD */}
            <div className="flex justify-between items-start">
                <div className="cyber-border p-4 rounded-tl-2xl rounded-br-2xl min-w-[150px]">
                    <div className="text-xs text-cyan-400 uppercase tracking-widest">Score</div>
                    <div className="text-4xl font-black neon-text">{score.toLocaleString()}</div>
                </div>
                
                <div className="text-center">
                    <div className={`px-4 py-1 rounded text-sm font-bold mb-2 ${status === 'READY' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}`}>
                        ‚óè {status}
                    </div>
                    {combo > 1 && (
                        <div className="text-2xl italic font-black text-yellow-400 animate-bounce">
                            {combo}x COMBO
                        </div>
                    )}
                </div>

                <div className="cyber-border p-4 rounded-tr-2xl rounded-bl-2xl text-right">
                    <div className="text-xs text-cyan-400 uppercase tracking-widest">Targeting</div>
                    <div className="text-sm font-mono opacity-80">ACTIVE_LASER_V4</div>
                </div>
            </div>

            {/* Bottom Branding */}
            <div className="flex flex-col items-center gap-2">
                <a 
                    href="https://aiinsight.vn" 
                    target="_blank" 
                    className="pointer-events-auto text-cyan-400/50 hover:text-cyan-400 transition-colors text-xs tracking-[0.3em] uppercase font-light"
                >
                    aiinsight.vn
                </a>
            </div>
        </div>
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>

</body>
</html>